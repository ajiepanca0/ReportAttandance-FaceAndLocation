{
    "sourceFile": "face_training_testing.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 28,
            "patches": [
                {
                    "date": 1686830619939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1686831226557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,40 +7,45 @@\n import face_recognition\r\n from face_recognition.face_recognition_cli import image_files_in_folder\r\n import numpy as np\r\n from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-from sklearn.metrics import confusion_matrix\r\n \r\n ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n \r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n     encodings = []\r\n     names = []\r\n \r\n+    # Direktori Pelatihan\r\n     train_people = os.listdir(train_dir)\r\n     print(train_people)\r\n \r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n     for person in train_people:\r\n         pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n+    \r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n         for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n             print(os.path.join(train_dir, person, person_img))\r\n             face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n             print(face.shape)\r\n-\r\n+            \r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n             height, width, _ = face.shape\r\n             face_location = (0, width, height, 0)\r\n             face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n             face_enc = np.array(face_enc)\r\n             face_enc = face_enc.flatten()\r\n-\r\n+        \r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n             encodings.append(face_enc)\r\n             names.append(person)\r\n \r\n     print(np.array(encodings).shape)\r\n-\r\n+    \r\n+    # Bagi data menjadi set latihan dan pengujian\r\n     unique_names = np.unique(names)\r\n     encodings_train = []\r\n     encodings_test = []\r\n     names_train = []\r\n@@ -52,40 +57,50 @@\n         encodings_train.extend(encodings_train_name)\r\n         encodings_test.extend(encodings_test_name)\r\n         names_train.extend(names_train_name)\r\n         names_test.extend(names_test_name)\r\n-\r\n+    \r\n+    # Buat dan latih klasifikasi KNN\r\n     knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n     knn_clf.fit(encodings_train, names_train)\r\n \r\n+    # Evaluasi klasifikasi pada data pengujian\r\n     predictions = knn_clf.predict(encodings_test)\r\n     accuracy = accuracy_score(names_test, predictions)\r\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n+    \r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n \r\n-    cm = confusion_matrix(names_test, predictions)\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i+1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n \r\n-    sns.heatmap(cm, annot=True)\r\n-    plt.savefig('confusion_matrix.png')\r\n-    print(cm)\r\n-\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n     print(\"Recall:\", recall)\r\n     print(\"Laporan Klasifikasi:\\n\", report)\r\n \r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n     if model_save_path is not None:\r\n         with open(model_save_path, 'wb') as f:\r\n             pickle.dump(knn_clf, f)\r\n \r\n     num_training_data = len(encodings_train)\r\n     num_testing_data = len(encodings_test)\r\n-\r\n+    \r\n     messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n \r\n     return knn_clf\r\n \r\n if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n+    print(\"Pelatihan selesai!\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686831515345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,45 +7,39 @@\n import face_recognition\r\n from face_recognition.face_recognition_cli import image_files_in_folder\r\n import numpy as np\r\n from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n \r\n ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n \r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n     encodings = []\r\n     names = []\r\n \r\n-    # Direktori Pelatihan\r\n     train_people = os.listdir(train_dir)\r\n     print(train_people)\r\n \r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n     for person in train_people:\r\n         pix = os.listdir(os.path.join(train_dir, person))\r\n-    \r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+\r\n         for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n             print(os.path.join(train_dir, person, person_img))\r\n             face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n             print(face.shape)\r\n-            \r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n+\r\n             height, width, _ = face.shape\r\n             face_location = (0, width, height, 0)\r\n             face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n             face_enc = np.array(face_enc)\r\n             face_enc = face_enc.flatten()\r\n-        \r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+\r\n             encodings.append(face_enc)\r\n             names.append(person)\r\n \r\n     print(np.array(encodings).shape)\r\n-    \r\n-    # Bagi data menjadi set latihan dan pengujian\r\n+\r\n     unique_names = np.unique(names)\r\n     encodings_train = []\r\n     encodings_test = []\r\n     names_train = []\r\n@@ -57,50 +51,47 @@\n         encodings_train.extend(encodings_train_name)\r\n         encodings_test.extend(encodings_test_name)\r\n         names_train.extend(names_train_name)\r\n         names_test.extend(names_test_name)\r\n-    \r\n-    # Buat dan latih klasifikasi KNN\r\n+\r\n     knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n     knn_clf.fit(encodings_train, names_train)\r\n \r\n-    # Evaluasi klasifikasi pada data pengujian\r\n     predictions = knn_clf.predict(encodings_test)\r\n     accuracy = accuracy_score(names_test, predictions)\r\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n-    \r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n \r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i+1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    plot_confusion_matrix(cm, unique_names)\r\n \r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n     print(\"Recall:\", recall)\r\n     print(\"Laporan Klasifikasi:\\n\", report)\r\n \r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n     if model_save_path is not None:\r\n         with open(model_save_path, 'wb') as f:\r\n             pickle.dump(knn_clf, f)\r\n \r\n     num_training_data = len(encodings_train)\r\n     num_testing_data = len(encodings_test)\r\n-    \r\n+\r\n     messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n \r\n     return knn_clf\r\n \r\n+def plot_confusion_matrix(conf_matrix, classes):\r\n\\ No newline at end of file\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(conf_matrix, annot=True, fmt=\"d\", cmap=\"Blues\", cbar=False)\r\n+    plt.xticks(np.arange(len(classes)), classes, rotation=45)\r\n+    plt.yticks(np.arange(len(classes)), classes, rotation=0)\r\n+    plt.xlabel(\"Predicted\")\r\n+    plt.ylabel(\"True\")\r\n+    plt.title(\"Confusion Matrix\")\r\n+    plt.show()\r\n+\r\n if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686831535431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,97 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+from face_recognition.face_recognition_cli import image_files_in_folder\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        for person_img in pix:\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    plot_confusion_matrix(cm, unique_names)\r\n+\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    return knn_clf\r\n+\r\n+def plot_confusion_matrix(conf_matrix, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(conf_matrix, annot=True, fmt=\"d\", cmap=\"Blues\", cbar=False)\r\n+    plt.xticks(np.arange(len(classes)), classes, rotation=45)\r\n+    plt.yticks(np.arange(len(classes)), classes, rotation=0)\r\n+    plt.xlabel(\"Predicted\")\r\n+    plt.ylabel(\"True\")\r\n+    plt.title(\"Confusion Matrix\")\r\n+    plt.show()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686832136564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,137 +6,46 @@\n import pickle\r\n import face_recognition\r\n from face_recognition.face_recognition_cli import image_files_in_folder\r\n import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        for person_img in pix:\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    plot_confusion_matrix(cm, unique_names)\r\n-\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    return knn_clf\r\n-\r\n-def plot_confusion_matrix(conf_matrix, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(conf_matrix, annot=True, fmt=\"d\", cmap=\"Blues\", cbar=False)\r\n-    plt.xticks(np.arange(len(classes)), classes, rotation=45)\r\n-    plt.yticks(np.arange(len(classes)), classes, rotation=0)\r\n-    plt.xlabel(\"Predicted\")\r\n-    plt.ylabel(\"True\")\r\n-    plt.title(\"Confusion Matrix\")\r\n-    plt.show()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n \r\n ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n \r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n     encodings = []\r\n     names = []\r\n \r\n+    # Direktori Pelatihan\r\n     train_people = os.listdir(train_dir)\r\n     print(train_people)\r\n \r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n     for person in train_people:\r\n         pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n+    \r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n         for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n             print(os.path.join(train_dir, person, person_img))\r\n             face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n             print(face.shape)\r\n-\r\n+            \r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n             height, width, _ = face.shape\r\n             face_location = (0, width, height, 0)\r\n             face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n             face_enc = np.array(face_enc)\r\n             face_enc = face_enc.flatten()\r\n-\r\n+        \r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n             encodings.append(face_enc)\r\n             names.append(person)\r\n \r\n     print(np.array(encodings).shape)\r\n-\r\n+    \r\n+    # Bagi data menjadi set latihan dan pengujian\r\n     unique_names = np.unique(names)\r\n     encodings_train = []\r\n     encodings_test = []\r\n     names_train = []\r\n@@ -148,47 +57,50 @@\n         encodings_train.extend(encodings_train_name)\r\n         encodings_test.extend(encodings_test_name)\r\n         names_train.extend(names_train_name)\r\n         names_test.extend(names_test_name)\r\n-\r\n+    \r\n+    # Buat dan latih klasifikasi KNN\r\n     knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n     knn_clf.fit(encodings_train, names_train)\r\n \r\n+    # Evaluasi klasifikasi pada data pengujian\r\n     predictions = knn_clf.predict(encodings_test)\r\n     accuracy = accuracy_score(names_test, predictions)\r\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n+    \r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n \r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    plot_confusion_matrix(cm, unique_names)\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i+1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n \r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n     print(\"Recall:\", recall)\r\n     print(\"Laporan Klasifikasi:\\n\", report)\r\n \r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n     if model_save_path is not None:\r\n         with open(model_save_path, 'wb') as f:\r\n             pickle.dump(knn_clf, f)\r\n \r\n     num_training_data = len(encodings_train)\r\n     num_testing_data = len(encodings_test)\r\n-\r\n+    \r\n     messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n \r\n     return knn_clf\r\n \r\n-def plot_confusion_matrix(conf_matrix, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(conf_matrix, annot=True, fmt=\"d\", cmap=\"Blues\", cbar=False)\r\n-    plt.xticks(np.arange(len(classes)), classes, rotation=45)\r\n-    plt.yticks(np.arange(len(classes)), classes, rotation=0)\r\n-    plt.xlabel(\"Predicted\")\r\n-    plt.ylabel(\"True\")\r\n-    plt.title(\"Confusion Matrix\")\r\n-    plt.show()\r\n-\r\n if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686832216464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,18 +69,18 @@\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n     \r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n+    # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    distances, indices = knn_clf.kneighbors(encodings_test)\r\n \r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i+1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+    for i, distance in enumerate(distances):\r\n+        print(f\"Data testing ke-{i+1}:\")\r\n+        for j, dist in enumerate(distance):\r\n+            training_data_index = indices[i][j]\r\n+            training_data_name = names_train[training_data_index]\r\n+            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n \r\n     # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n"
                },
                {
                    "date": 1686832484923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,10 @@\n import face_recognition\r\n from face_recognition.face_recognition_cli import image_files_in_folder\r\n import numpy as np\r\n from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n \r\n ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n \r\n # Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n@@ -22,29 +24,29 @@\n \r\n     # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n     for person in train_people:\r\n         pix = os.listdir(os.path.join(train_dir, person))\r\n-    \r\n+\r\n         # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n         for person_img in pix:\r\n             # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n             print(os.path.join(train_dir, person, person_img))\r\n             face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n             print(face.shape)\r\n-            \r\n+\r\n             # Anggap seluruh gambar adalah lokasi wajah\r\n             height, width, _ = face.shape\r\n             face_location = (0, width, height, 0)\r\n             face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n             face_enc = np.array(face_enc)\r\n             face_enc = face_enc.flatten()\r\n-        \r\n+\r\n             # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n             encodings.append(face_enc)\r\n             names.append(person)\r\n \r\n     print(np.array(encodings).shape)\r\n-    \r\n+\r\n     # Bagi data menjadi set latihan dan pengujian\r\n     unique_names = np.unique(names)\r\n     encodings_train = []\r\n     encodings_test = []\r\n@@ -52,14 +54,15 @@\n     names_test = []\r\n     for name in unique_names:\r\n         name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n         name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n         encodings_train.extend(encodings_train_name)\r\n         encodings_test.extend(encodings_test_name)\r\n         names_train.extend(names_train_name)\r\n         names_test.extend(names_test_name)\r\n-    \r\n+\r\n     # Buat dan latih klasifikasi KNN\r\n     knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n     knn_clf.fit(encodings_train, names_train)\r\n \r\n@@ -68,14 +71,14 @@\n     accuracy = accuracy_score(names_test, predictions)\r\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n-    \r\n+\r\n     # Tambahkan kode untuk menampilkan jarak inklusi\r\n     distances, indices = knn_clf.kneighbors(encodings_test)\r\n \r\n     for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i+1}:\")\r\n+        print(f\"Data testing ke-{i + 1}:\")\r\n         for j, dist in enumerate(distance):\r\n             training_data_index = indices[i][j]\r\n             training_data_name = names_train[training_data_index]\r\n             testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n@@ -93,14 +96,23 @@\n             pickle.dump(knn_clf, f)\r\n \r\n     num_training_data = len(encodings_train)\r\n     num_testing_data = len(encodings_test)\r\n-    \r\n-    messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n \r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+\r\n+    # Visualisasikan confusion matrix menggunakan heatmap dari seaborn\r\n\\ No newline at end of file\n+    sns.heatmap(cm, annot=True)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n     return knn_clf\r\n \r\n+\r\n if __name__ == \"__main__\":\r\n     # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686832496681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n import pickle\r\n import face_recognition\r\n from face_recognition.face_recognition_cli import image_files_in_folder\r\n import numpy as np\r\n-from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n import seaborn as sns\r\n import matplotlib.pyplot as plt\r\n \r\n ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n@@ -114,5 +114,5 @@\n if __name__ == \"__main__\":\r\n     # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\n\\ No newline at end of file\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686832518566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,117 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+from face_recognition.face_recognition_cli import image_files_in_folder\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    for i, distance in enumerate(distances):\r\n+        print(f\"Data testing ke-{i + 1}:\")\r\n+        for j, dist in enumerate(distance):\r\n+            training_data_index = indices[i][j]\r\n+            training_data_name = names_train[training_data_index]\r\n+            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+\r\n+    # Visualisasikan confusion matrix menggunakan heatmap dari seaborn\r\n+    sns.heatmap(cm, annot=True)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686832540435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,117 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+from face_recognition.face_recognition_cli import image_files_in_folder\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    for i, distance in enumerate(distances):\r\n+        print(f\"Data testing ke-{i + 1}:\")\r\n+        for j, dist in enumerate(distance):\r\n+            training_data_index = indices[i][j]\r\n+            training_data_name = names_train[training_data_index]\r\n+            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+\r\n+    # Visualisasikan confusion matrix menggunakan heatmap dari seaborn\r\n+    sns.heatmap(cm, annot=True)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686832644160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,126 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+from face_recognition.face_recognition_cli import image_files_in_folder\r\n+import numpy as np\r\n+from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    for i, distance in enumerate(distances):\r\n+        print(f\"Data testing ke-{i + 1}:\")\r\n+        for j, dist in enumerate(distance):\r\n+            training_data_index = indices[i][j]\r\n+            training_data_name = names_train[training_data_index]\r\n+            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686832652461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,126 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+from face_recognition.face_recognition_cli import image_files_in_folder\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    for i, distance in enumerate(distances):\r\n+        print(f\"Data testing ke-{i + 1}:\")\r\n+        for j, dist in enumerate(distance):\r\n+            training_data_index = indices[i][j]\r\n+            training_data_name = names_train[training_data_index]\r\n+            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686833461435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,8 +87,10 @@\n     # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n     print(\"Recall:\", recall)\r\n+    print(\"Jumlah data training :\", num_training_data)\r\n+    print(\"Jumlah data testing :\", num_testing_data_data)\r\n     print(\"Laporan Klasifikasi:\\n\", report)\r\n \r\n     # Simpan klasifikasi KNN yang telah dilatih\r\n     if model_save_path is not None:\r\n@@ -123,482 +125,4 @@\n     # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n-from sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i + 1}:\")\r\n-        for j, dist in enumerate(distance):\r\n-            training_data_index = indices[i][j]\r\n-            training_data_name = names_train[training_data_index]\r\n-            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i + 1}:\")\r\n-        for j, dist in enumerate(distance):\r\n-            training_data_index = indices[i][j]\r\n-            training_data_name = names_train[training_data_index]\r\n-            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-\r\n-    # Visualisasikan confusion matrix menggunakan heatmap dari seaborn\r\n-    sns.heatmap(cm, annot=True)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i + 1}:\")\r\n-        for j, dist in enumerate(distance):\r\n-            training_data_index = indices[i][j]\r\n-            training_data_name = names_train[training_data_index]\r\n-            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-\r\n-    # Visualisasikan confusion matrix menggunakan heatmap dari seaborn\r\n-    sns.heatmap(cm, annot=True)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i + 1}:\")\r\n-        for j, dist in enumerate(distance):\r\n-            training_data_index = indices[i][j]\r\n-            training_data_name = names_train[training_data_index]\r\n-            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-\r\n-    # Visualisasikan confusion matrix menggunakan heatmap dari seaborn\r\n-    sns.heatmap(cm, annot=True)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686833472156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,128 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+from face_recognition.face_recognition_cli import image_files_in_folder\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    for i, distance in enumerate(distances):\r\n+        print(f\"Data testing ke-{i + 1}:\")\r\n+        for j, dist in enumerate(distance):\r\n+            training_data_index = indices[i][j]\r\n+            training_data_name = names_train[training_data_index]\r\n+            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Jumlah data training :\", num_training_data)\r\n+    print(\"Jumlah data testing :\", num_testing_data)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686835618756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,10 +87,8 @@\n     # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n     print(\"Recall:\", recall)\r\n-    print(\"Jumlah data training :\", num_training_data)\r\n-    print(\"Jumlah data testing :\", num_testing_data)\r\n     print(\"Laporan Klasifikasi:\\n\", report)\r\n \r\n     # Simpan klasifikasi KNN yang telah dilatih\r\n     if model_save_path is not None:\r\n@@ -125,132 +123,4 @@\n     # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i + 1}:\")\r\n-        for j, dist in enumerate(distance):\r\n-            training_data_index = indices[i][j]\r\n-            training_data_name = names_train[training_data_index]\r\n-            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Jumlah data training :\", num_training_data)\r\n-    print(\"Jumlah data testing :\", num_testing_data_data)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686838507629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,18 +72,18 @@\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n \r\n-    # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    distances, indices = knn_clf.kneighbors(encodings_test)\r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n \r\n-    for i, distance in enumerate(distances):\r\n-        print(f\"Data testing ke-{i + 1}:\")\r\n-        for j, dist in enumerate(distance):\r\n-            training_data_index = indices[i][j]\r\n-            training_data_name = names_train[training_data_index]\r\n-            testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-            print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i + 1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n \r\n     # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n"
                },
                {
                    "date": 1686870340855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,125 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i + 1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686875452008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \r\n             # Anggap seluruh gambar adalah lokasi wajah\r\n             height, width, _ = face.shape\r\n             face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = face_recognition.face_landmarks(face, known_face_locations=[face_location])\r\n             face_enc = np.array(face_enc)\r\n             face_enc = face_enc.flatten()\r\n \r\n             # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n@@ -122,130 +122,4 @@\n     # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-from face_recognition.face_recognition_cli import image_files_in_folder\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i + 1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686875581183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,125 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i + 1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686882739070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,129 +122,4 @@\n     # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_landmarks(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i + 1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686883523332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,125 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i + 1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686889446471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,125 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition_test\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition_test.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition_test.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i + 1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686907028753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,125 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import face_recognition_test\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+\r\n+# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    # Direktori Pelatihan\r\n+    train_people = os.listdir(train_dir)\r\n+    print(train_people)\r\n+\r\n+    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n+        for person_img in pix:\r\n+            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n+            print(os.path.join(train_dir, person, person_img))\r\n+            face = face_recognition_test.load_image_file(os.path.join(train_dir, person, person_img))\r\n+            print(face.shape)\r\n+\r\n+            # Anggap seluruh gambar adalah lokasi wajah\r\n+            height, width, _ = face.shape\r\n+            face_location = (0, width, height, 0)\r\n+            face_enc = face_recognition_test.face_encodings(face, known_face_locations=[face_location])\r\n+            face_enc = np.array(face_enc)\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    # print(np.array(encodings).shape)\r\n+\r\n+    # Bagi data menjadi set latihan dan pengujian\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    # Buat dan latih klasifikasi KNN\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    # Evaluasi klasifikasi pada data pengujian\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n+    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n+\r\n+    # for i, distance in enumerate(distances):\r\n+    #     print(f\"Data testing ke-{i + 1}:\")\r\n+    #     for j, dist in enumerate(distance):\r\n+    #         training_data_index = indices[i][j]\r\n+    #         training_data_name = names_train[training_data_index]\r\n+    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n+    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n+\r\n+    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    # Simpan klasifikasi KNN yang telah dilatih\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    # Buat confusion matrix\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # Latih klasifikasi KNN dan simpan ke disk\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686978032697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,50 +3,101 @@\n from sklearn.model_selection import train_test_split\r\n import os\r\n import os.path\r\n import pickle\r\n-import face_recognition_test\r\n import numpy as np\r\n from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n import seaborn as sns\r\n import matplotlib.pyplot as plt\r\n+import PIL.Image\r\n+import dlib\r\n+import cv2\r\n+from PIL import ImageFile\r\n \r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n+ImageFile.LOAD_TRUNCATED_IMAGES = True\r\n \r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n+face_encoder = dlib.face_recognition_model_v1(\"model/dlib_face_recognition_resnet_model_v1.dat\")\r\n+pose_predictor_68_point = dlib.shape_predictor(\"model/shape_predictor_68_face_landmarks.dat\")\r\n+\r\n+\r\n+def _raw_face_locations(face_image, number_of_times_to_upsample=2, model=\"hog\"):\r\n+    if model == \"hog\":\r\n+        # Inisialisasi detektor wajah menggunakan HOG\r\n+        face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n+\r\n+        # Konversi gambar menjadi grayscale\r\n+        gray = cv2.cvtColor(face_image, cv2.COLOR_BGR2GRAY)\r\n+\r\n+        # Deteksi wajah menggunakan HOG\r\n+        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n+\r\n+        # Mendapatkan koordinat wajah yang terdeteksi\r\n+        face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n+    else:\r\n+        # Default: Gunakan detektor wajah dlib\r\n+        face_locations = face_detector(face_image, number_of_times_to_upsample)\r\n+\r\n+    return face_locations\r\n+\r\n+def _raw_face_landmarks(face_image, face_locations=None, model=\"large\"):\r\n+    if face_locations is None:\r\n+        face_locations = _raw_face_locations(face_image)\r\n+\r\n+    # Konversi koordinat wajah menjadi dlib.rectangle\r\n+    dlib_rects = [dlib.rectangle(left=x1, top=y1, right=x2, bottom=y2) for (x1, y1, x2, y2) in face_locations]\r\n+\r\n+    landmarks = [pose_predictor_68_point(face_image, face_location) for face_location in dlib_rects]\r\n+\r\n+    return landmarks\r\n+\r\n+\r\n+def face_encodings(face_image, known_face_locations=None, num_jitters=2, model=\"large\"):\r\n+    raw_landmarks = _raw_face_landmarks(face_image, known_face_locations)\r\n+    return [np.array(face_encoder.compute_face_descriptor(face_image, raw_landmark_set, num_jitters)) for raw_landmark_set in raw_landmarks]\r\n+\r\n+\r\n+def load_image_file(file, mode='RGB'):\r\n+    im = PIL.Image.open(file)\r\n+    if mode:\r\n+        im = im.convert(mode)\r\n+    return np.array(im)\r\n+\r\n+\r\n+def face_detection_hog(image):\r\n+    # Inisialisasi detektor wajah menggunakan HOG\r\n+    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n+\r\n+    # Konversi gambar menjadi grayscale\r\n+    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n+\r\n+    # Deteksi wajah menggunakan HOG\r\n+    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n+\r\n+    # Mendapatkan koordinat wajah yang terdeteksi\r\n+    face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n+\r\n+    return face_locations\r\n+\r\n+\r\n def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n     encodings = []\r\n     names = []\r\n \r\n-    # Direktori Pelatihan\r\n     train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n \r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n     for person in train_people:\r\n         pix = os.listdir(os.path.join(train_dir, person))\r\n \r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n         for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition_test.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n+            face = load_image_file(os.path.join(train_dir, person, person_img))\r\n \r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition_test.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n+            face_locations = face_detection_hog(face)\r\n+            face_enc = face_encodings(face, known_face_locations=face_locations)[0]\r\n             face_enc = face_enc.flatten()\r\n \r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n             encodings.append(face_enc)\r\n             names.append(person)\r\n \r\n-    # print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n     unique_names = np.unique(names)\r\n     encodings_train = []\r\n     encodings_test = []\r\n     names_train = []\r\n@@ -60,37 +111,22 @@\n         encodings_test.extend(encodings_test_name)\r\n         names_train.extend(names_train_name)\r\n         names_test.extend(names_test_name)\r\n \r\n-    # Buat dan latih klasifikasi KNN\r\n     knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n     knn_clf.fit(encodings_train, names_train)\r\n \r\n-    # Evaluasi klasifikasi pada data pengujian\r\n     predictions = knn_clf.predict(encodings_test)\r\n     accuracy = accuracy_score(names_test, predictions)\r\n     precision = precision_score(names_test, predictions, average='weighted')\r\n     recall = recall_score(names_test, predictions, average='weighted')\r\n     report = classification_report(names_test, predictions)\r\n \r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i + 1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n     print(\"Akurasi:\", accuracy)\r\n     print(\"Presisi:\", precision)\r\n     print(\"Recall:\", recall)\r\n     print(\"Laporan Klasifikasi:\\n\", report)\r\n \r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n     if model_save_path is not None:\r\n         with open(model_save_path, 'wb') as f:\r\n             pickle.dump(knn_clf, f)\r\n \r\n@@ -99,9 +135,8 @@\n \r\n     messagebox.showinfo(\"Pelatihan Selesai\",\r\n                         f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n \r\n-    # Buat confusion matrix\r\n     cm = confusion_matrix(names_test, predictions)\r\n     class_names = np.unique(names)\r\n     plot_confusion_matrix(cm, class_names)\r\n     plt.savefig('confusion_Matrix.png')\r\n@@ -118,8 +153,7 @@\n     plt.xticks(rotation=45)\r\n \r\n \r\n if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686978214437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,153 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+import PIL.Image\r\n+import dlib\r\n+import cv2\r\n+from PIL import ImageFile\r\n+\r\n+ImageFile.LOAD_TRUNCATED_IMAGES = True\r\n+\r\n+face_encoder = dlib.face_recognition_model_v1(\"model/dlib_face_recognition_resnet_model_v1.dat\")\r\n+pose_predictor_68_point = dlib.shape_predictor(\"model/shape_predictor_68_face_landmarks.dat\")\r\n+face_detector = dlib.get_frontal_face_detector()\r\n+\r\n+def _raw_face_locations(face_image, number_of_times_to_upsample=2, model=\"hog\"):\r\n+    if model == \"hog\":\r\n+        # Initialize the face detector using HOG\r\n+        face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n+\r\n+        # Convert the image to grayscale\r\n+        gray = cv2.cvtColor(face_image, cv2.COLOR_BGR2GRAY)\r\n+\r\n+        # Detect faces using HOG\r\n+        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n+\r\n+        # Get the detected face coordinates\r\n+        face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n+    else:\r\n+        # Default: Use the dlib face detector\r\n+        face_locations = face_detector(face_image, number_of_times_to_upsample)\r\n+\r\n+    return face_locations\r\n+\r\n+def _raw_face_landmarks(face_image, face_locations=None, model=\"large\"):\r\n+    if face_locations is None:\r\n+        face_locations = _raw_face_locations(face_image)\r\n+\r\n+    # Convert face coordinates to dlib.rectangle\r\n+    dlib_rects = [dlib.rectangle(left=x1, top=y1, right=x2, bottom=y2) for (x1, y1, x2, y2) in face_locations]\r\n+\r\n+    landmarks = [pose_predictor_68_point(face_image, face_location) for face_location in dlib_rects]\r\n+\r\n+    return landmarks\r\n+\r\n+def face_encodings(face_image, known_face_locations=None, num_jitters=2, model=\"large\"):\r\n+    raw_landmarks = _raw_face_landmarks(face_image, known_face_locations)\r\n+    return [np.array(face_encoder.compute_face_descriptor(face_image, raw_landmark_set, num_jitters)) for raw_landmark_set in raw_landmarks]\r\n+\r\n+def load_image_file(file, mode='RGB'):\r\n+    im = PIL.Image.open(file)\r\n+    if mode:\r\n+        im = im.convert(mode)\r\n+    return np.array(im)\r\n+\r\n+def face_detection_hog(image):\r\n+    # Initialize the face detector using HOG\r\n+    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n+\r\n+    # Convert the image to grayscale\r\n+    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n+\r\n+    # Detect faces using HOG\r\n+    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n+\r\n+    # Get the detected face coordinates\r\n+    face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n+\r\n+    return face_locations\r\n+\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    train_people = os.listdir(train_dir)\r\n+\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(train_dir, person))\r\n+\r\n+        for person_img in pix:\r\n+            face = load_image_file(os.path.join(train_dir, person, person_img))\r\n+\r\n+            face_locations = face_detection_hog(face)\r\n+            face_enc = face_encodings(face, known_face_locations=face_locations)[0]\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+if __name__ == \"__main__\":\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686978847883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,8 +77,9 @@\n def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n     encodings = []\r\n     names = []\r\n \r\n+    train_dir = os.listdir('datase/')\r\n     train_people = os.listdir(train_dir)\r\n \r\n     for person in train_people:\r\n         pix = os.listdir(os.path.join(train_dir, person))\r\n@@ -150,538 +151,4 @@\n if __name__ == \"__main__\":\r\n     print(\"Mengtraining klasifikasi KNN...\")\r\n     classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n     print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-import PIL.Image\r\n-import dlib\r\n-import cv2\r\n-from PIL import ImageFile\r\n-\r\n-ImageFile.LOAD_TRUNCATED_IMAGES = True\r\n-\r\n-face_encoder = dlib.face_recognition_model_v1(\"model/dlib_face_recognition_resnet_model_v1.dat\")\r\n-pose_predictor_68_point = dlib.shape_predictor(\"model/shape_predictor_68_face_landmarks.dat\")\r\n-\r\n-\r\n-def _raw_face_locations(face_image, number_of_times_to_upsample=2, model=\"hog\"):\r\n-    if model == \"hog\":\r\n-        # Inisialisasi detektor wajah menggunakan HOG\r\n-        face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n-\r\n-        # Konversi gambar menjadi grayscale\r\n-        gray = cv2.cvtColor(face_image, cv2.COLOR_BGR2GRAY)\r\n-\r\n-        # Deteksi wajah menggunakan HOG\r\n-        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n-\r\n-        # Mendapatkan koordinat wajah yang terdeteksi\r\n-        face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n-    else:\r\n-        # Default: Gunakan detektor wajah dlib\r\n-        face_locations = face_detector(face_image, number_of_times_to_upsample)\r\n-\r\n-    return face_locations\r\n-\r\n-def _raw_face_landmarks(face_image, face_locations=None, model=\"large\"):\r\n-    if face_locations is None:\r\n-        face_locations = _raw_face_locations(face_image)\r\n-\r\n-    # Konversi koordinat wajah menjadi dlib.rectangle\r\n-    dlib_rects = [dlib.rectangle(left=x1, top=y1, right=x2, bottom=y2) for (x1, y1, x2, y2) in face_locations]\r\n-\r\n-    landmarks = [pose_predictor_68_point(face_image, face_location) for face_location in dlib_rects]\r\n-\r\n-    return landmarks\r\n-\r\n-\r\n-def face_encodings(face_image, known_face_locations=None, num_jitters=2, model=\"large\"):\r\n-    raw_landmarks = _raw_face_landmarks(face_image, known_face_locations)\r\n-    return [np.array(face_encoder.compute_face_descriptor(face_image, raw_landmark_set, num_jitters)) for raw_landmark_set in raw_landmarks]\r\n-\r\n-\r\n-def load_image_file(file, mode='RGB'):\r\n-    im = PIL.Image.open(file)\r\n-    if mode:\r\n-        im = im.convert(mode)\r\n-    return np.array(im)\r\n-\r\n-\r\n-def face_detection_hog(image):\r\n-    # Inisialisasi detektor wajah menggunakan HOG\r\n-    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n-\r\n-    # Konversi gambar menjadi grayscale\r\n-    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n-\r\n-    # Deteksi wajah menggunakan HOG\r\n-    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n-\r\n-    # Mendapatkan koordinat wajah yang terdeteksi\r\n-    face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n-\r\n-    return face_locations\r\n-\r\n-\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    train_people = os.listdir(train_dir)\r\n-\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        for person_img in pix:\r\n-            face = load_image_file(os.path.join(train_dir, person, person_img))\r\n-\r\n-            face_locations = face_detection_hog(face)\r\n-            face_enc = face_encodings(face, known_face_locations=face_locations)[0]\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition_test\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition_test.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition_test.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i + 1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i + 1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n-from tkinter import messagebox\r\n-from sklearn import neighbors\r\n-from sklearn.model_selection import train_test_split\r\n-import os\r\n-import os.path\r\n-import pickle\r\n-import face_recognition\r\n-import numpy as np\r\n-from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n-import seaborn as sns\r\n-import matplotlib.pyplot as plt\r\n-\r\n-ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n-\r\n-# Data latih berisi semua enkode wajah dari semua gambar yang dikenal, dan labelnya adalah nama mereka\r\n-def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n-    encodings = []\r\n-    names = []\r\n-\r\n-    # Direktori Pelatihan\r\n-    train_people = os.listdir(train_dir)\r\n-    print(train_people)\r\n-\r\n-    # Perulangan akan melalui setiap dataset dalam direktori pelatihan\r\n-    for person in train_people:\r\n-        pix = os.listdir(os.path.join(train_dir, person))\r\n-\r\n-        # Loop melalui setiap gambar latih untuk orang yang saat ini\r\n-        for person_img in pix:\r\n-            # Dapatkan enkode wajah untuk wajah di setiap file gambar\r\n-            print(os.path.join(train_dir, person, person_img))\r\n-            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n-            print(face.shape)\r\n-\r\n-            # Anggap seluruh gambar adalah lokasi wajah\r\n-            height, width, _ = face.shape\r\n-            face_location = (0, width, height, 0)\r\n-            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n-            face_enc = np.array(face_enc)\r\n-            face_enc = face_enc.flatten()\r\n-\r\n-            # Tambahkan enkode wajah untuk gambar saat ini dengan label yang sesuai (nama) ke data latihan\r\n-            encodings.append(face_enc)\r\n-            names.append(person)\r\n-\r\n-    print(np.array(encodings).shape)\r\n-\r\n-    # Bagi data menjadi set latihan dan pengujian\r\n-    unique_names = np.unique(names)\r\n-    encodings_train = []\r\n-    encodings_test = []\r\n-    names_train = []\r\n-    names_test = []\r\n-    for name in unique_names:\r\n-        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n-        name_labels = [n for n in names if n == name]\r\n-        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n-            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n-        encodings_train.extend(encodings_train_name)\r\n-        encodings_test.extend(encodings_test_name)\r\n-        names_train.extend(names_train_name)\r\n-        names_test.extend(names_test_name)\r\n-\r\n-    # Buat dan latih klasifikasi KNN\r\n-    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n-    knn_clf.fit(encodings_train, names_train)\r\n-\r\n-    # Evaluasi klasifikasi pada data pengujian\r\n-    predictions = knn_clf.predict(encodings_test)\r\n-    accuracy = accuracy_score(names_test, predictions)\r\n-    precision = precision_score(names_test, predictions, average='weighted')\r\n-    recall = recall_score(names_test, predictions, average='weighted')\r\n-    report = classification_report(names_test, predictions)\r\n-\r\n-    # # Tambahkan kode untuk menampilkan jarak inklusi\r\n-    # distances, indices = knn_clf.kneighbors(encodings_test)\r\n-\r\n-    # for i, distance in enumerate(distances):\r\n-    #     print(f\"Data testing ke-{i + 1}:\")\r\n-    #     for j, dist in enumerate(distance):\r\n-    #         training_data_index = indices[i][j]\r\n-    #         training_data_name = names_train[training_data_index]\r\n-    #         testing_data_name = names_test[i]  # Menyimpan nama data testing\r\n-    #         print(f\"Jarak inklusi dengan data training {training_data_name} dan data testing {testing_data_name}: {dist}\")\r\n-\r\n-    # Cetak hasil Akurasi, Presisi, Recall, dan Laporan Klasifikasi\r\n-    print(\"Akurasi:\", accuracy)\r\n-    print(\"Presisi:\", precision)\r\n-    print(\"Recall:\", recall)\r\n-    print(\"Laporan Klasifikasi:\\n\", report)\r\n-\r\n-    # Simpan klasifikasi KNN yang telah dilatih\r\n-    if model_save_path is not None:\r\n-        with open(model_save_path, 'wb') as f:\r\n-            pickle.dump(knn_clf, f)\r\n-\r\n-    num_training_data = len(encodings_train)\r\n-    num_testing_data = len(encodings_test)\r\n-\r\n-    messagebox.showinfo(\"Pelatihan Selesai\",\r\n-                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n-\r\n-    # Buat confusion matrix\r\n-    cm = confusion_matrix(names_test, predictions)\r\n-    class_names = np.unique(names)\r\n-    plot_confusion_matrix(cm, class_names)\r\n-    plt.savefig('confusion_Matrix.png')\r\n-\r\n-    return knn_clf\r\n-\r\n-\r\n-def plot_confusion_matrix(cm, classes):\r\n-    plt.figure(figsize=(8, 6))\r\n-    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n-    plt.title('Confusion Matrix')\r\n-    plt.xlabel('Predicted Label')\r\n-    plt.ylabel('True Label')\r\n-    plt.xticks(rotation=45)\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # Latih klasifikasi KNN dan simpan ke disk\r\n-    print(\"Mengtraining klasifikasi KNN...\")\r\n-    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n-    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686978895507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,154 @@\n+from tkinter import messagebox\r\n+from sklearn import neighbors\r\n+from sklearn.model_selection import train_test_split\r\n+import os\r\n+import os.path\r\n+import pickle\r\n+import numpy as np\r\n+from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, classification_report\r\n+import seaborn as sns\r\n+import matplotlib.pyplot as plt\r\n+import PIL.Image\r\n+import dlib\r\n+import cv2\r\n+from PIL import ImageFile\r\n+\r\n+ImageFile.LOAD_TRUNCATED_IMAGES = True\r\n+\r\n+face_encoder = dlib.face_recognition_model_v1(\"model/dlib_face_recognition_resnet_model_v1.dat\")\r\n+pose_predictor_68_point = dlib.shape_predictor(\"model/shape_predictor_68_face_landmarks.dat\")\r\n+face_detector = dlib.get_frontal_face_detector()\r\n+\r\n+def _raw_face_locations(face_image, number_of_times_to_upsample=2, model=\"hog\"):\r\n+    if model == \"hog\":\r\n+        # Initialize the face detector using HOG\r\n+        face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n+\r\n+        # Convert the image to grayscale\r\n+        gray = cv2.cvtColor(face_image, cv2.COLOR_BGR2GRAY)\r\n+\r\n+        # Detect faces using HOG\r\n+        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n+\r\n+        # Get the detected face coordinates\r\n+        face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n+    else:\r\n+        # Default: Use the dlib face detector\r\n+        face_locations = face_detector(face_image, number_of_times_to_upsample)\r\n+\r\n+    return face_locations\r\n+\r\n+def _raw_face_landmarks(face_image, face_locations=None, model=\"large\"):\r\n+    if face_locations is None:\r\n+        face_locations = _raw_face_locations(face_image)\r\n+\r\n+    # Convert face coordinates to dlib.rectangle\r\n+    dlib_rects = [dlib.rectangle(left=x1, top=y1, right=x2, bottom=y2) for (x1, y1, x2, y2) in face_locations]\r\n+\r\n+    landmarks = [pose_predictor_68_point(face_image, face_location) for face_location in dlib_rects]\r\n+\r\n+    return landmarks\r\n+\r\n+def face_encodings(face_image, known_face_locations=None, num_jitters=2, model=\"large\"):\r\n+    raw_landmarks = _raw_face_landmarks(face_image, known_face_locations)\r\n+    return [np.array(face_encoder.compute_face_descriptor(face_image, raw_landmark_set, num_jitters)) for raw_landmark_set in raw_landmarks]\r\n+\r\n+def load_image_file(file, mode='RGB'):\r\n+    im = PIL.Image.open(file)\r\n+    if mode:\r\n+        im = im.convert(mode)\r\n+    return np.array(im)\r\n+\r\n+def face_detection_hog(image):\r\n+    # Initialize the face detector using HOG\r\n+    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\r\n+\r\n+    # Convert the image to grayscale\r\n+    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\r\n+\r\n+    # Detect faces using HOG\r\n+    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))\r\n+\r\n+    # Get the detected face coordinates\r\n+    face_locations = [(x, y, x + w, y + h) for (x, y, w, h) in faces]\r\n+\r\n+    return face_locations\r\n+\r\n+def train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n+    encodings = []\r\n+    names = []\r\n+\r\n+    train_dir = os.listdir('datase/')\r\n+    train_people = os.listdir(train_dir)\r\n+\r\n+    for person in train_people:\r\n+        pix = os.listdir(os.path.join(\"dataset/\", person))\r\n+\r\n+        for person_img in pix:\r\n+            face = load_image_file(os.path.join(train_dir, person, person_img))\r\n+\r\n+            face_locations = face_detection_hog(face)\r\n+            face_enc = face_encodings(face, known_face_locations=face_locations)[0]\r\n+            face_enc = face_enc.flatten()\r\n+\r\n+            encodings.append(face_enc)\r\n+            names.append(person)\r\n+\r\n+    unique_names = np.unique(names)\r\n+    encodings_train = []\r\n+    encodings_test = []\r\n+    names_train = []\r\n+    names_test = []\r\n+    for name in unique_names:\r\n+        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n+        name_labels = [n for n in names if n == name]\r\n+        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(\r\n+            name_encodings, name_labels, test_size=0.3, random_state=42)\r\n+        encodings_train.extend(encodings_train_name)\r\n+        encodings_test.extend(encodings_test_name)\r\n+        names_train.extend(names_train_name)\r\n+        names_test.extend(names_test_name)\r\n+\r\n+    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n+    knn_clf.fit(encodings_train, names_train)\r\n+\r\n+    predictions = knn_clf.predict(encodings_test)\r\n+    accuracy = accuracy_score(names_test, predictions)\r\n+    precision = precision_score(names_test, predictions, average='weighted')\r\n+    recall = recall_score(names_test, predictions, average='weighted')\r\n+    report = classification_report(names_test, predictions)\r\n+\r\n+    print(\"Akurasi:\", accuracy)\r\n+    print(\"Presisi:\", precision)\r\n+    print(\"Recall:\", recall)\r\n+    print(\"Laporan Klasifikasi:\\n\", report)\r\n+\r\n+    if model_save_path is not None:\r\n+        with open(model_save_path, 'wb') as f:\r\n+            pickle.dump(knn_clf, f)\r\n+\r\n+    num_training_data = len(encodings_train)\r\n+    num_testing_data = len(encodings_test)\r\n+\r\n+    messagebox.showinfo(\"Pelatihan Selesai\",\r\n+                        f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n+\r\n+    cm = confusion_matrix(names_test, predictions)\r\n+    class_names = np.unique(names)\r\n+    plot_confusion_matrix(cm, class_names)\r\n+    plt.savefig('confusion_Matrix.png')\r\n+\r\n+    return knn_clf\r\n+\r\n+def plot_confusion_matrix(cm, classes):\r\n+    plt.figure(figsize=(8, 6))\r\n+    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\r\n+    plt.title('Confusion Matrix')\r\n+    plt.xlabel('Predicted Label')\r\n+    plt.ylabel('True Label')\r\n+    plt.xticks(rotation=45)\r\n+\r\n+if __name__ == \"__main__\":\r\n+    print(\"Mengtraining klasifikasi KNN...\")\r\n+    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n+    print(\"Pelatihan selesai!\")\r\n"
                },
                {
                    "date": 1686978928129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,11 +78,11 @@\n     encodings = []\r\n     names = []\r\n \r\n     train_dir = os.listdir('dataset/')\r\n-    train_people = os.listdir(train_dir)\r\n+    print(train_dir)\r\n \r\n-    for person in train_people:\r\n+    for person in train_dir:\r\n         pix = os.listdir(os.path.join(\"dataset/\", person))\r\n \r\n         for person_img in pix:\r\n             face = load_image_file(os.path.join(train_dir, person, person_img))\r\n"
                },
                {
                    "date": 1686978934644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -81,9 +81,9 @@\n     train_dir = os.listdir('dataset/')\r\n     print(train_dir)\r\n \r\n     for person in train_dir:\r\n-        pix = os.listdir(os.path.join(\"dataset/\", person))\r\n+        pix = os.listdir(os.path.join(\"dataset/\", + person))\r\n \r\n         for person_img in pix:\r\n             face = load_image_file(os.path.join(train_dir, person, person_img))\r\n \r\n"
                }
            ],
            "date": 1686830619939,
            "name": "Commit-0",
            "content": "from tkinter import messagebox\r\nfrom sklearn import neighbors\r\nfrom sklearn.model_selection import train_test_split\r\nimport os\r\nimport os.path\r\nimport pickle\r\nimport face_recognition\r\nfrom face_recognition.face_recognition_cli import image_files_in_folder\r\nimport numpy as np\r\nfrom sklearn.metrics import precision_score, recall_score, accuracy_score, classification_report\r\nimport seaborn as sns\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.metrics import confusion_matrix\r\n\r\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}\r\n\r\ndef train(train_dir, model_save_path=None, n_neighbors=9, knn_algo='ball_tree', verbose=False):\r\n    encodings = []\r\n    names = []\r\n\r\n    train_people = os.listdir(train_dir)\r\n    print(train_people)\r\n\r\n    for person in train_people:\r\n        pix = os.listdir(os.path.join(train_dir, person))\r\n\r\n        for person_img in pix:\r\n            print(os.path.join(train_dir, person, person_img))\r\n            face = face_recognition.load_image_file(os.path.join(train_dir, person, person_img))\r\n            print(face.shape)\r\n\r\n            height, width, _ = face.shape\r\n            face_location = (0, width, height, 0)\r\n            face_enc = face_recognition.face_encodings(face, known_face_locations=[face_location])\r\n            face_enc = np.array(face_enc)\r\n            face_enc = face_enc.flatten()\r\n\r\n            encodings.append(face_enc)\r\n            names.append(person)\r\n\r\n    print(np.array(encodings).shape)\r\n\r\n    unique_names = np.unique(names)\r\n    encodings_train = []\r\n    encodings_test = []\r\n    names_train = []\r\n    names_test = []\r\n    for name in unique_names:\r\n        name_encodings = [encoding for encoding, n in zip(encodings, names) if n == name]\r\n        name_labels = [n for n in names if n == name]\r\n        encodings_train_name, encodings_test_name, names_train_name, names_test_name = train_test_split(name_encodings, name_labels, test_size=0.3, random_state=42)\r\n        encodings_train.extend(encodings_train_name)\r\n        encodings_test.extend(encodings_test_name)\r\n        names_train.extend(names_train_name)\r\n        names_test.extend(names_test_name)\r\n\r\n    knn_clf = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors, algorithm=knn_algo, weights='distance')\r\n    knn_clf.fit(encodings_train, names_train)\r\n\r\n    predictions = knn_clf.predict(encodings_test)\r\n    accuracy = accuracy_score(names_test, predictions)\r\n    precision = precision_score(names_test, predictions, average='weighted')\r\n    recall = recall_score(names_test, predictions, average='weighted')\r\n    report = classification_report(names_test, predictions)\r\n\r\n    cm = confusion_matrix(names_test, predictions)\r\n\r\n    sns.heatmap(cm, annot=True)\r\n    plt.savefig('confusion_matrix.png')\r\n    print(cm)\r\n\r\n    print(\"Akurasi:\", accuracy)\r\n    print(\"Presisi:\", precision)\r\n    print(\"Recall:\", recall)\r\n    print(\"Laporan Klasifikasi:\\n\", report)\r\n\r\n    if model_save_path is not None:\r\n        with open(model_save_path, 'wb') as f:\r\n            pickle.dump(knn_clf, f)\r\n\r\n    num_training_data = len(encodings_train)\r\n    num_testing_data = len(encodings_test)\r\n\r\n    messagebox.showinfo(\"Pelatihan Selesai\", f\"Pelatihan selesai!\\n\\nAkurasi: {accuracy:.2f}\\nPresisi: {precision:.2f}\\nRecall: {recall:.2f}\\n\\nJumlah data latihan: {num_training_data}\\nJumlah data pengujian: {num_testing_data}\")\r\n\r\n    return knn_clf\r\n\r\nif __name__ == \"__main__\":\r\n    print(\"Mengtraining klasifikasi KNN...\")\r\n    classifier = train(\"dataset\", model_save_path=\"model/trained_knn_model.clf\", n_neighbors=9)\r\n    print(\"Pelatihan selesai!\")\r\n"
        }
    ]
}