{
    "sourceFile": "face_knn.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1686980534148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1686983525846,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+import math\r\n+import operator\r\n+\r\n+\r\n+class Classifier:\r\n+    def __init__(self, n_neighbors=3, thresh=0.6):\r\n+        self.k = n_neighbors\r\n+        self.thresh = thresh\r\n+        self._samples = []\r\n+        self._labels = []\r\n+\r\n+    def add_pair(self, sample, label):\r\n+        self._samples.append(sample)\r\n+        self._labels.append(label)\r\n+\r\n+    @staticmethod\r\n+    def euclidean_distance(instance1, instance2, length):\r\n+        distance = 0\r\n+        for x in range(length):\r\n+            distance += pow((instance1[x] - instance2[x]), 2)\r\n+        return math.sqrt(distance)\r\n+\r\n+    def predict(self, target):\r\n+        if len(self._labels) == 0:\r\n+            return 0\r\n+\r\n+        distances = []\r\n+        length = len(target)\r\n+        for x in range(len(self._samples)):\r\n+            dist = self.euclidean_distance(target, self._samples[x], length)\r\n+            if dist < self.thresh:\r\n+                distances.append((self._samples[x], dist, self._labels[x]))\r\n+\r\n+        if not distances:\r\n+            return 0\r\n+\r\n+        distances.sort(key=operator.itemgetter(1))\r\n+        n = self.k\r\n+        if n > len(distances):\r\n+            n = len(distances)\r\n+\r\n+        class_votes = dict()\r\n+        for x in range(n):\r\n+            response = distances[x][2]\r\n+            if response in class_votes:\r\n+                class_votes[response] += 1\r\n+            else:\r\n+                class_votes[response] = 1\r\n+        sorted_otes = sorted(class_votes.iteritems(), key=operator.itemgetter(1), reverse=True)\r\n+\r\n+        return sorted_otes[0][0]\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686984641241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+import math\r\n+import operator\r\n+\r\n+\r\n+class Classifier:\r\n+    def __init__(self, n_neighbors=3, thresh=0.6):\r\n+        self.k = n_neighbors\r\n+        self.thresh = thresh\r\n+        self._samples = []\r\n+        self._labels = []\r\n+\r\n+    def add_pair(self, sample, label):\r\n+        self._samples.append(sample)\r\n+        self._labels.append(label)\r\n+\r\n+    @staticmethod\r\n+    def euclidean_distance(instance1, instance2, length):\r\n+        distance = 0\r\n+        for x in range(length):\r\n+            distance += pow((instance1[x] - instance2[x]), 2)\r\n+        return math.sqrt(distance)\r\n+\r\n+    def predict(self, target):\r\n+        if len(self._labels) == 0:\r\n+            return 0\r\n+\r\n+        distances = []\r\n+        length = len(target)\r\n+        for x in range(len(self._samples)):\r\n+            dist = self.euclidean_distance(target, self._samples[x], length)\r\n+            if dist < self.thresh:\r\n+                distances.append((self._samples[x], dist, self._labels[x]))\r\n+\r\n+        if not distances:\r\n+            return 0\r\n+\r\n+        distances.sort(key=operator.itemgetter(1))\r\n+        n = self.k\r\n+        if n > len(distances):\r\n+            n = len(distances)\r\n+\r\n+        class_votes = dict()\r\n+        for x in range(n):\r\n+            response = distances[x][2]\r\n+            if response in class_votes:\r\n+                class_votes[response] += 1\r\n+            else:\r\n+                class_votes[response] = 1\r\n+        sorted_otes = sorted(class_votes.iteritems(), key=operator.itemgetter(1), reverse=True)\r\n+\r\n+        return sorted_otes[0][0]\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686986123844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,63 @@\n+import math\r\n+import operator\r\n+\r\n+\r\n+class Classifier:\r\n+    def __init__(self,\r\n+        n_neighbors=5,\r\n+        *,\r\n+        weights=\"uniform\",\r\n+        algorithm=\"auto\",\r\n+        leaf_size=30,\r\n+        p=2,\r\n+        metric=\"minkowski\",\r\n+        metric_params=None,\r\n+        n_jobs=None,):\r\n+        n_neighbors=n_neighbors,\r\n+            algorithm=algorithm,\r\n+            leaf_size=leaf_size,\r\n+            metric=metric,\r\n+            p=p,\r\n+            metric_params=metric_params,\r\n+            n_jobs=n_jobs,\r\n+\r\n+    def add_pair(self, sample, label):\r\n+        self._samples.append(sample)\r\n+        self._labels.append(label)\r\n+\r\n+    @staticmethod\r\n+    def euclidean_distance(instance1, instance2, length):\r\n+        distance = 0\r\n+        for x in range(length):\r\n+            distance += pow((instance1[x] - instance2[x]), 2)\r\n+        return math.sqrt(distance)\r\n+\r\n+    def predict(self, target):\r\n+        if len(self._labels) == 0:\r\n+            return 0\r\n+\r\n+        distances = []\r\n+        length = len(target)\r\n+        for x in range(len(self._samples)):\r\n+            dist = self.euclidean_distance(target, self._samples[x], length)\r\n+            if dist < self.thresh:\r\n+                distances.append((self._samples[x], dist, self._labels[x]))\r\n+\r\n+        if not distances:\r\n+            return 0\r\n+\r\n+        distances.sort(key=operator.itemgetter(1))\r\n+        n = self.k\r\n+        if n > len(distances):\r\n+            n = len(distances)\r\n+\r\n+        class_votes = dict()\r\n+        for x in range(n):\r\n+            response = distances[x][2]\r\n+            if response in class_votes:\r\n+                class_votes[response] += 1\r\n+            else:\r\n+                class_votes[response] = 1\r\n+        sorted_otes = sorted(class_votes.iteritems(), key=operator.itemgetter(1), reverse=True)\r\n+\r\n+        return sorted_otes[0][0]\n\\ No newline at end of file\n"
                },
                {
                    "date": 1686986129424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n         p=2,\r\n         metric=\"minkowski\",\r\n         metric_params=None,\r\n         n_jobs=None,):\r\n-        n_neighbors=n_neighbors,\r\n+            n_neighbors=n_neighbors,\r\n             algorithm=algorithm,\r\n             leaf_size=leaf_size,\r\n             metric=metric,\r\n             p=p,\r\n"
                },
                {
                    "date": 1686986201519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,25 +2,13 @@\n import operator\r\n \r\n \r\n class Classifier:\r\n-    def __init__(self,\r\n-        n_neighbors=5,\r\n-        *,\r\n-        weights=\"uniform\",\r\n-        algorithm=\"auto\",\r\n-        leaf_size=30,\r\n-        p=2,\r\n-        metric=\"minkowski\",\r\n-        metric_params=None,\r\n-        n_jobs=None,):\r\n-            n_neighbors=n_neighbors,\r\n-            algorithm=algorithm,\r\n-            leaf_size=leaf_size,\r\n-            metric=metric,\r\n-            p=p,\r\n-            metric_params=metric_params,\r\n-            n_jobs=n_jobs,\r\n+    def __init__(self, n_neighbors=3, thresh=0.6):\r\n+        self.k = n_neighbors\r\n+        self.thresh = thresh\r\n+        self._samples = []\r\n+        self._labels = []\r\n \r\n     def add_pair(self, sample, label):\r\n         self._samples.append(sample)\r\n         self._labels.append(label)\r\n"
                }
            ],
            "date": 1686980534148,
            "name": "Commit-0",
            "content": "import math\r\nimport operator\r\n\r\n\r\nclass Classifier:\r\n    def __init__(self, k=3, thresh=0.6):\r\n        self.k = k\r\n        self.thresh = thresh\r\n        self._samples = []\r\n        self._labels = []\r\n\r\n    def add_pair(self, sample, label):\r\n        self._samples.append(sample)\r\n        self._labels.append(label)\r\n\r\n    @staticmethod\r\n    def euclidean_distance(instance1, instance2, length):\r\n        distance = 0\r\n        for x in range(length):\r\n            distance += pow((instance1[x] - instance2[x]), 2)\r\n        return math.sqrt(distance)\r\n\r\n    def predict(self, target):\r\n        if len(self._labels) == 0:\r\n            return 0\r\n\r\n        distances = []\r\n        length = len(target)\r\n        for x in range(len(self._samples)):\r\n            dist = self.euclidean_distance(target, self._samples[x], length)\r\n            if dist < self.thresh:\r\n                distances.append((self._samples[x], dist, self._labels[x]))\r\n\r\n        if not distances:\r\n            return 0\r\n\r\n        distances.sort(key=operator.itemgetter(1))\r\n        n = self.k\r\n        if n > len(distances):\r\n            n = len(distances)\r\n\r\n        class_votes = dict()\r\n        for x in range(n):\r\n            response = distances[x][2]\r\n            if response in class_votes:\r\n                class_votes[response] += 1\r\n            else:\r\n                class_votes[response] = 1\r\n        sorted_otes = sorted(class_votes.iteritems(), key=operator.itemgetter(1), reverse=True)\r\n\r\n        return sorted_otes[0][0]"
        }
    ]
}